*******************************************************************
*                                                                 *
*                Tiny BASIC for the Motorola MC68000              *
*                                                                 *
* Derived from Palo Alto Tiny BASIC as published in the May 1976  *
* issue of Dr. Dobb's Journal.  Orginally Adapted to the          *
* 68000 by:                                                       *
*        Gordon Brandly                                           *
*        R.R. 2                                                   *
*        Fort Sask., Alberta, CANADA                              *
*        T8L 2N8                                                  *
*                                                                 *
* ST version adapted by:                                          *
*        Kenneth L. Hurley                                        *
*        1230 W 7th #3                                            *
*        Eugene, OR  97402                                        *
*                                                                 *
*                Version 1.0 as of July 17, 1984                  *
*                Version 2.0 as of January 4, 1986                *
*                                                                 *
*                                                                 *
* This version is for Atari 520 ST.                               *
*                                                                 *
* Die urspruengliche TOS-Version 2.0 dieser Software ist auf der  *
* ATARI PD-Diskette 210 der V-Serie veroeffentlicht worden.       *
* Anpassung an RTOS-PEARL als Version 3.0 fuer RTOS-ASM 4.2F oder *
* neuer durch Rolf Hemmerling.                                    *
*                                                                 *
* Last Update 11.08.94                                            *
*                                                                 *
*******************************************************************

*
* Wahl der Betriebssystems-Schnittstelle OS=TOS/RTOS 
* Hier funktioniert natuerlich nur RTOS !!!
*
RTOS      EQU       1
TOS       EQU       0
OS        EQU       RTOS


TASK         EQU        1
PROC         EQU        0

*
* TINY BASIC ist PROCEDURE oder TASK
*
VERSION      EQU        TASK

* 
* Prioritaet bei TINY BASIC als TASK
*
TPRIO        EQU        $30
           
* 
* INCLUDE 'sINCLAS' 
*

CR           EQU        $0D  ;ASCII equates
LF           EQU        $0A
TAB          EQU        $09
CTRLC        EQU        $03
CTRLH        EQU        $08
CTRLS        EQU        $13
CTRLX        EQU        $18
SPACE        EQU        $20  ;' '
DQUOTE       EQU        $22  ;'"'  
SQUOTE       EQU        $27  ;'''' 
MINUS        EQU        $2D  ;'-'
POINT        EQU        $2E  ;'.'
N0           EQU        $30
N1           EQU        $31
N9           EQU        $39 
COLON        EQU        $3A  ;':'
GREATER      EQU        $3E  ;'>'
QMARK        EQU        $3F  ;'?'
ATXX         EQU        $40  ;'@'
AXX          EQU        $41  ;'A' 
AYY          EQU        $61  ;'a'
ZYY          EQU        $7A  ;'z' 
USTRICH      EQU        $5F  ;'_'

BUFLEN       EQU        128    ;length of keyboard input buffer

* 
* TRAPS
*
TERMI      OPD     $4E41       ;TERMINATE INTERNAL 
QDPC       OPD     $4E43       ;DISPATCHER CALL 
FETCE      OPD     $4E48       ;FETCH COMMUNICATION-ELEMENT 
RELCE      OPD     $4E49       ;RELEASE CE 
XIO        OPD     $4E4A       ;TRANSFER CE FOR INPUT/OUTPUT 
RETN       OPD     $4E4C       ;RETURN FROM PROCEDURE 
TOV        OPD     $4E4E       ;## HYPERPROCESSOR ON 
OFF        OPD     $4E4F       ;SWITCH DISPATCHER OFF + SUPERVISORMODE 
IOWA       OPD     $A00A       ;I/O WAIT FUNCTION 

*
* Hypercodes
*
TOREAL     OPD.V     0 ; ABSCHALTEN DES HYPERPROZESSORS 
EPAR       OPD.V    19 ; END OF PARAMETERLIST 
ENTR       OPD.V    29 ; PROZEDUREINTRITT MIT PWSP-ERZEUGUNG 
CALLEX     OPD   $12C0 ; PROCEDURE CALL (EXT)

* 
* CE - AUFBAU (E-II-2) 
* 
TIDO       EQU     $15         ;.L TASK-ID OF OWNER 
PRIO       EQU     $1E         ;.W PLAZIERUNGSPRIO IN DER QUEUE 
BUADR      EQU     $20         ;.L BUFFER-ADRESS 
RECLEN     EQU     $24         ;.L BLOCKLAENGE IN BYTES 
STATIO     EQU     $26         ;.B STATUSBYTE 
LDNIO      EQU     $27         ;.B LDN DER WARTESCHLANGE DES CE 
MODE       EQU     $28         ;.W BETRIEBSART,ENDEBEDINGUNG,.. 
M2ODE      EQU     $29         ;.W FLOPPY-FILEHANDLER KOMMANDOS
DRV        EQU     $2A         ;.W DRIVE-NO ODER ACIA-MODE 
FNAME      EQU     $2C         ;FILENAME ... $FF 
* 
* BEDEUTUNG DER EINZELNEN BITS IM MODE-WORD (E-III-2,3) 
* 
* 1.BYTE 
* 
MODMWA     EQU     $80         ;SUSPEND (WAIT) UNTIL READY 
MODMOU     EQU     $40         ;OUTPUT-DIRECTION 
MODMCR     EQU     $20         ;AUTO-STOP AFTER TRANSMISSION OF CR 
MODMLF     EQU     $10         ;AUTO-STOP AFTER TRANSMISSION OF LF 
MODMEO     EQU     $08         ;AUTO-STOP AFTER TRANSMISSION OF EOF 
MODMSC     EQU     $04         ;SUPPRESS COMMAND-INP.(ACIA) 
MODMNE     EQU     $02         ;NO ECHO ON INPUT (ACIA,SCC) 
MODBIN     EQU     $01         ;BINAERER TRANSFER 
* 
* 2.BYTE 
* 
IOCEF      EQU     $80         ;RUECKMELDEBIT BEI EINGABE: EOF 
NERR       EQU     $40         ;NO ERROR MESSAGES 
IOCNE      EQU     $40         ;NO ERROR MESSAGES 
EXCLU      EQU     $20         ;EXCLUSIV ACCESS 
FREAD      EQU     $00         ;READ/WRITE 'OLD' FILE
FCLOSE     EQU     $06         ;CLOSE FILE
FWRITE     EQU     $07         ;READ/WRITE 'ANY' FILE
FOPEN      EQU     $08         ;REWIND 'OLD' FILE
FCREATE    EQU     $15         ;REWIND 'ANY' FILE
FREWIND    EQU     $16         ;REWIND NEW

*
* REGISTERVERWENDUNG
*
*     TOS                  RTOS
*
* A0   Y
* A1   Y
* A2   Y
* A3   Y
* A4   Y                   N --> TSP
* A5   Y                   N --> PSP (.X)
* A6   Y
* A7   "SP"                "A7" 
*
* CCR  "CCR"               Bytezugriff auf "SR" 
*
* D0   Y
* D1   Y
* D2   Y
* D3   Y
* D4   Y
* D5   N                   Y (anstelle von A5)
* D6   N                   Y (anstelle von A4)
* D7   N                   Y (fuer CMP-absolute Adressen)

*
* 
* PWSP-ALLOCATION 
* 

RANPNT       EQU        0  ;.L   random number pointer
OLDSTACK     EQU        4  ;.L   end of memory pointer
FHANDLE      EQU        8  ;.W   file handle for file operations
OUTBYTE      EQU       10  ;.B   output the byte to the file
INBYTE       EQU       11  ;.B   input the byte from the file
FILENAME     EQU       12  ;.B66 buffer for the filename
CURRNT       EQU       78  ;.L   Current line pointer
STKGOS       EQU       82  ;.L   Saves stack pointer in 'GOSUB'
STKINP       EQU       86  ;.L   Saves stack pointer during 'INPUT'
LOPVAR       EQU       90  ;.L   'FOR' loop save area
LOPINC       EQU       94  ;.L   increment
LOPLMT       EQU       98  ;.L   limit
LOPLN        EQU      102  ;.L   line number
LOPPT        EQU      106  ;.L   text pointer
TXTBGN       EQU      110  ;.L   points to beginning of program memory
TXTUNF       EQU      114  ;.L   points to unfilled text area
VARBGN       EQU      118  ;.L   points to variable area
STKLMT       EQU      122  ;.L   holds lower limit for stack growth
BUFFER       EQU      126  ;.B*BUFLEN Keyboard input buffer
TXT          EQU      512  ;.B   Programmbereich
WSPSZ        EQU      32766


* 
* MODULE HEAD FOR RTOS 
* 
        .IF     VERSION
TB0     DC.L    TB1
        .ELSE
TB1     DC.L    0
        .FIN
        DC.L    0         ;FOR LOADER 
        DC      $0010     ;TYPE: MDLE 
        DC.B    'BASICA'  ;6 BYTES NAME-LINK 

        .IF     VERSION
* 
* TASK HEAD FOR RTOS 
* 
TB1     DC.L    0
        DC.L    TB0       ;FOR LOADER 
        DC      $0001     ;TYPE: TASK
        DC.B    'BASIC '  ;6 BYTES NAME-LINK 
        DC      TPRIO
        DC.L    $70
        DC.L    0,0
        DC      TPRIO
        DC.L    TB2
        DC.L    0,0,0,0,0,0,0,0
        DC.L    0,0,0,0,0,0,0,0
        
*
* TASK Startcode
*
TB2     TOV     
        CALLEX 
        DC.L    >BASICA
        EPAR
        TERMI

        .FIN

*
* Standard jump table. You can change these addresses if you are
* customizing this interpreter for a different environment.
*
>BASICA ENTR    WSPSZ.L 
        EPAR 
        NOP
* 
* Register fuer RTOS-Hyperprozessor Wiedereintritt retten
* 
*
        MOVE.L     A7,OLDSTACK.X  ;Save the end of memory

START   BRA        CSTART     ;Cold Start entry point
GOWARM  BRA        WSTART     ;Warm Start entry point
GOOUT   BRA        OUTCH      ;Jump to character-out routine
GOIN    BRA        INCH       ;Jump to character-in routine
GOAUXO  BRA        AUXOUT     ;Jump to auxiliary-out routine
GOAUXI  BRA        AUXIN      ;Jump to auxiliary-in routine
GOBYE   BRA        BYEBYE     ;Jump to monitor, DOS, etc.
        .IF        VERSION 
GOOUT2  BRA        OUTCH2     ;Jump to character-out routine
        .FIN 
*
* Modifiable system constants:
*
*TXTBGN  DC.L       TXT                beginning of program memory
*
* The main interpreter starts here:
*
CSTART  NOP
*zzz    MOVEA.L    OLDSTACK.X,A7     ;initialize stack pointer
        LEA        WSPSZ.X,A7      ;initialize stack pointer
        LEA        INITMSG,A6      ;  tell who we are
        BSR        PRMESG          

*****
*
* TXTBGN Zeigerinitialisierung 
*
        LEA        TXT.X,A6
        MOVE.L     A6,TXTBGN.X     ;init. beginning of program memory
*
*****

        MOVE.L     TXTBGN.X,TXTUNF.X ;init. end-of-program pointer

*zzz    MOVE.L     OLDSTACK.X,D0     ;get address of end of memory
        EXG        A6,D0
        LEA        WSPSZ.X,A6        ;get address of end of memory
        EXG        A6,D0
        
        SUB.L      =2048,D0        ;reserve 2K for the stack
        MOVE.L     D0,STKLMT.X
        SUB.L      =108,D0       ;reserve variable area (27 long words)
        MOVE.L     D0,VARBGN.X
WSTART  CLR.L      D0              ;initialize internal variables
        MOVE.L     D0,LOPVAR.X
        MOVE.L     D0,STKGOS.X
        MOVE.L     D0,CURRNT.X     ;current line number pointer = 0
*zzz    MOVEA.L    OLDSTACK.X,A7     ;init S.P. again, just in case
        LEA        WSPSZ.X,A7     ;init S.P. again, just in case
        LEA        OKMSG,A6        ;display 'OK'
        BSR        PRMESG
ST3     MOVE.B     =GREATER,D0     ;Prompt with a '>' and
        BSR        GETLN           ;read a line.
        BSR        TOUPBUF         ;convert to upper case
*zzz    MOVEA.L    A0,A4           ;save pointer to end of line
        MOVE.L     A0,D6           ;save pointer to end of line
        LEA        BUFFER.X,A0     ;point to the beginning of line
        BSR        TSTNUM          ;is there a number there?
        BSR        IGNBLK          ;skip trailing blanks
        TST        D1              ;does line no. exist? (or nonzero?)
        BEQ        DIRECT          ;if not, it's a direct statement
        CMP.L      =$FFFF,D1       ;see if line no. is <= 16 bits
        BCC        QHOW            ;if not, we've overflowed
        MOVE.B     D1,-(A0)        ;store the binary line no.
        ROR        =8,D1           ;(Kludge to store a word on a
        MOVE.B     D1,-(A0)        ;possible byte boundary)
        ROL        =8,D1
        BSR        FNDLN           ;find this line in save area

*zzz    MOVEA.L    A1,A5           ;save possible line pointer
        MOVE       SR,-(A7)
        MOVE.L     A1,D5           ;save possible line pointer
        MOVE       (A7)+,CCR
        
        BNE        ST4             ;if not found, insert
        BSR        FNDNXT          ;find the next line (into A1)

*zzz    MOVEA.L    A5,A2           ;pointer to line to be deleted
        MOVEA.L    D5,A2           ;pointer to line to be deleted
        MOVEA.L    TXTUNF.X,A3     ;points to top of save area
        BSR        MVUP            ;move up to delete
        MOVE.L     A2,TXTUNF.X     ;update the end pointer
ST4     NOP
*zzz    MOVE.L     A4,D0           ;calculate the length of new line
        MOVE.L     D6,D0           ;calculate the length of new line
        SUB.L      A0,D0
        CMP.L      =3,D0           ;is it just a line no. & CR?
        BEQ        ST3             ;if so, it was just a delete
        MOVEA.L    TXTUNF.X,A3     ;compute new end
        MOVEA.L    A3,A6
        ADDA.L     D0,A3
        MOVE.L     VARBGN.X,D0     ;see if there's enough room
        CMP.L      A3,D0
        BLS        QSORRY          ;if not, say so
        MOVE.L     A3,TXTUNF.X     ;if so, store new end position
        MOVEA.L    A6,A1           ;points to old unfilled area
*zzz    MOVEA.L    A5,A2           ;points to beginning of move area
        MOVEA.L    D5,A2           ;points to beginning of move area
        BSR        MVDOWN          ;move things out of the way
        MOVEA.L    A0,A1           ;set up to do the insertion
*zzz    MOVEA.L    A5,A2
        MOVEA.L    D5,A2
*zzz    MOVEA.L    A4,A3
        MOVEA.L    D6,A3
        BSR        MVUP            ;do it
        BRA        ST3             ;go back and get another line

*
*******************************************************************
*
* *** Tables *** DIRECT *** EXEC ***
*
* This section of the code tests a string against a table. When
* a match is found, control is transferred to the section of
* code according to the table.
*
* At 'EXEC', A0 should point to the string, A1 should point to
* the character table, and A2 should point to the execution
* table. At 'DIRECT', A0 should point to the string, A1 and
* A2 will be set up to point to TAB1 and TAB11, which are
* the tables of all direct and statement commands.
*
* A '.' in the string will terminate the test and the partial
* match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
* 'PRIN.', or 'PRINT' will all match 'PRINT'.
*
* There are two tables: the character table and the execution
* table. The character table consists of any number of text items.
* Each item is a string of characters with the last character's
* high bit set to one. The execution table holds a 16-bit
* execution addresses that correspond to each entry in the
* character table.
*
* The end of the character table is a 0 byte which corresponds
* to the default routine in the execution table, which is
* executed if none of the other table items are matched.
*
* Character-matching tables:

TAB1    DC.B       'LIS',$54+$80    ;'T'+$80 Direct commands
        DC.B       'LOA',$44+$80    ;'D'+$80
        DC.B       'NE',$57+$80     ;'W'+$80
        DC.B       'RU',$4E+$80     ;'N'+$80
        DC.B       'SAV',$45+$80    ;'E'+$80
TAB2    DC.B       'NEX',$54+$80    ;'T'+$80 Direct / statement
        DC.B       'LE',$54+$80     ;'T'+$80
        DC.B       'I',$46+$80      ;'F'+$80
        DC.B       'GOT',$4F+$80    ;'O'+$80
        DC.B       'GOSU',$42+$80   ;'B'+$80
        DC.B       'RETUR',$4E+$80  ;'N'+$80
        DC.B       'RE',$4D+$80     ;'M'+$80
        DC.B       'FO',$52+$80     ;'R'+$80
        DC.B       'INPU',$54+$80   ;'T'+$80
        DC.B       'PRIN',$54+$80   ;'T'+$80
        DC.B       'POK',$45+$80    ;'E'+$80
        DC.B       'STO',$50+$80    ;'P'+$80
        DC.B       'BY',$45+$80     ;'E'+$80
        DC.B       'CAL',$4C+$80    ;'L'+$80
        DC.B       0
TAB4    DC.B       'PEE',$4B+$80    ;'K'+$80 Functions
        DC.B       'RN',$44+$80     ;'D'+$80
        DC.B       'AB',$53+$80     ;'S'+$80
        DC.B       'SIZ',$45+$80    ;'E'+$80
        DC.B       0
TAB5    DC.B       'T',$4F+$80      ;'O'+$80 'TO' in 'FOR'
        DC.B       0
TAB6    DC.B       'STE',$50+$80    ;'P'+$80 'STEP' in 'FOR'
        DC.B       0
TAB8    DC.B       '>',$3D+$80      ;'='+$80 Relational operators
        DC.B       '<',$3E+$80      ;'>'+$80
        DC.B       $3E+$80          ;'>'+$80
        DC.B       $3D+$80          ;'='+$80
        DC.B       '<',$3D+$80      ;'='+$80
        DC.B       $3C+$80          ;'<'+$80
        DC.B       0
        DC.B       0        <- for aligning on a word boundary

* Execution address tables:
TAB11   DC.L       LIST                        Direct commands
        DC.L       LOAD
        DC.L       NEW
        DC.L       RUN
        DC.L       SAVE
TAB21   DC.L       NEXT                        Direct / statement
        DC.L       LET
        DC.L       IF
        DC.L       GOTO
        DC.L       GOSUB
        DC.L       RETURN
        DC.L       REM
        DC.L       FOR
        DC.L       INPUT
        DC.L       PRINT
        DC.L       POKE
        DC.L       STOPRG
        DC.L       GOBYE
        DC.L       CALL
        DC.L       DEFLT
TAB41   DC.L       PEEK                        Functions
        DC.L       RND
        DC.L       ABS
        DC.L       SIZE
        DC.L       XP40
TAB51   DC.L       FR1                        'TO' in 'FOR'
        DC.L       QWHAT
TAB61   DC.L       FR2                        'STEP' in 'FOR'
        DC.L       FR3
TAB81   DC.L       XP11        >=                Relational operators
        DC.L       XP12        <>
        DC.L       XP13        >
        DC.L       XP15        =
        DC.L       XP14        <=
        DC.L       XP16        <
        DC.L       XP17
*
DIRECT  LEA        TAB1,A1
        LEA        TAB11,A2
EXEC    BSR        IGNBLK                ignore leading blanks
        MOVEA.L    A0,A3                save the pointer
        CLR.B      D2                clear match flag
EXLP    MOVE.B     (A0)+,D0        get the program character
        MOVE.B     (A1),D1                get the table character
        BNE        EXNGO                If end of table,
        MOVEA.L    A3,A0                restore the text pointer and...
        BRA        EXGO                execute the default.
EXNGO   MOVE.B     D0,D3                Else check for period...
        AND.B      D2,D3                and a match.
        CMP.B      =POINT,D3
        BEQ        EXGO                if so, execute
        AND.B      =$7F,D1                ignore the table's high bit
        CMP.B      D0,D1                is there a match?
        BEQ        EXMAT
        ADDQ.L     =4,A2                if not, try the next entry
        MOVEA.L    A3,A0                reset the program pointer
        CLR.B      D2                sorry, no match
EX1     TST.B      (A1)+                get to the end of the entry
        BPL        EX1
        BRA        EXLP                back for more matching
EXMAT   MOVEQ      =-1,D2                we've got a match so far
        TST.B      (A1)+                end of table entry?
        BPL        EXLP                if not, go back for more
EXGO    LEA        0,A3               execute the appropriate routine
        MOVEA.L    (A2),A3
        JMP        (A3)
*
*******************************************************************
*
* What follows is the code to execute direct and statement
* commands. Control is transferred to these points via the command
* table lookup code of 'DIRECT' and 'EXEC' in the last section.
* After the command is executed, control is transferred to other
* sections as follows:
*
* For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
* For 'RUN': go execute the first stored line if any; else go
* back to the warm start point.
* For 'GOTO' and 'GOSUB': go execute the target line.
* For 'RETURN' and 'NEXT'; go back to saved return line.
* For all others: if 'CURRNT.X' is 0, go to warm start; else go
* execute next command. (This is done in 'FINISH'.)
*
*******************************************************************
*
* *** NEW *** STOP *** RUN (& friends) *** GOTO ***
*
* 'NEW<CR>' sets TXTUNF.X to point to TXTBGN.X
*
* 'STOP<CR>' goes back to WSTART
*
* 'RUN<CR>' finds the first stored line, stores its address
* in CURRNT.X, and starts executing it. Note that only those
* commands in TAB2 are legal for a stored program.
*
* There are 3 more entries in 'RUN':
* 'RUNNXL' finds next line, stores it's address and executes it.
* 'RUNTSL' stores the address of this line and executes it.
* 'RUNSML' continues the execution on same line.
*
* 'GOTO expr<CR>' evaluates the expression, finds the target
* line, and jumps to 'RUNTSL' to do it.
*
NEW     BSR        ENDCHK
        MOVE.L     TXTBGN.X,TXTUNF.X        set the end pointer

STOPRG  BSR        ENDCHK
        BRA        WSTART

RUN     BSR        ENDCHK
        MOVEA.L    TXTBGN.X,A0        set pointer to beginning
        MOVE.L     A0,CURRNT.X

RUNNXL  TST.L      CURRNT.X                executing a program?
        BEQ        WSTART          if not, we've finished a direct stat.
        CLR.L      D1                else find the next line number
        MOVEA.L    A0,A1
        BSR        FNDLNP
        BCS        WSTART          if we've fallen off the end, stop

RUNTSL  MOVE.L     A1,CURRNT.X     set CURRNT.X to point to the line no.
        MOVEA.L    A1,A0                set the text pointer to
        ADDQ.L     =2,A0                the start of the line text

RUNSML  BSR        CHKIO                see if a control-C was pressed
        LEA        TAB2,A1                find command in TAB2
        LEA        TAB21,A2
        BRA        EXEC                and execute it

GOTO    BSR        EXPR                evaluate the following expression
        BSR        ENDCHK                must find end of line
        MOVE.L     D0,D1
        BSR        FNDLN                find the target line
        BNE        QHOW                no such line no.
        BRA        RUNTSL                go do it

*
*******************************************************************
*
* *** LIST *** PRINT ***
*
* LIST has two forms:
* 'LIST<CR>' lists all saved lines
* 'LIST =<CR>' starts listing at the line =
* Control-S pauses the listing, control-C stops it.
*
* PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
* where '....' is a list of expressions, formats, back-arrows,
* and strings.  These items a separated by commas.
*
* A format is a pound sign followed by a number.  It controls
* the number of spaces the value of an expression is going to
* be printed in.  It stays effective for the rest of the print
* command unless changed by another format.  If no format is
* specified, 11 positions will be used.
*
* A string is quoted in a pair of single- or double-quotes.
*
* An underline (back-arrow) means generate a <CR> without a <LF>
*
* A <CR LF> is generated after the entire list has been printed
* or if the list is empty.  If the list ends with a semicolon,
* however, no <CR LF> is generated.
*

LIST    BSR        TSTNUM                see if there's a line no.
        BSR        ENDCHK                if not, we get a zero
        BSR        FNDLN                find this or next line
LS1     BCS        WSTART                warm start if we passed the end
        BSR        PRTLN                print the line
        BSR        CHKIO                check for listing halt request
        BEQ        LS3
        CMP.B      =CTRLS,D0        pause the listing?
        BNE        LS3
LS2     BSR        CHKIO                if so, wait for another keypress
        BEQ        LS2
LS3     BSR        FNDLNP                find the next line
        BRA        LS1

PRINT   MOVE       =11,D4                D4 = number of print spaces
        BSR        TSTC                if null list and ':'
        DC.B       ':',PR2-$
        BSR        CRLF                give CR-LF and continue
        BRA        RUNSML                execution on the same line
PR2     BSR        TSTC                if null list and <CR>
        DC.B       CR,PR0-$
        BSR        CRLF                also give CR-LF and
        BRA        RUNNXL                execute the next line
PR0     BSR        TSTC                else is it a format?
        DC.B       '#',PR1-$
        BSR        EXPR                yes, evaluate expression
        MOVE       D0,D4                and save it as print width
        BRA        PR3                look for more to print
PR1     BSR        QTSTG                is it a string?
*zzz    BRA        PR8      if not, must be an expression 
        BRA.S      PR8      if not, must be an expression 
PR3     BSR        TSTC                if ',', go find next
        DC.B       ',',PR6-$
        BSR        FIN                in the list.
        BRA        PR0
PR6     BSR        CRLF                list ends here
        BRA        FINISH
PR8     MOVE       D4,-(A7)        save the width value
        BSR        EXPR                evaluate the expression
        MOVE       (A7)+,D4        restore the width
        MOVE.L     D0,D1
        BSR        PRTNUM                print its value
        BRA        PR3                more to print?

FINISH  BSR        FIN                Check end of command
        BRA        QWHAT                print 'What?' if wrong

*
*******************************************************************
*
* *** GOSUB *** & RETURN ***
*
* 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
* except that the current text pointer, stack pointer, etc. are
* saved so that execution can be continued after the subroutine
* 'RETURN's.  In order that 'GOSUB' can be nested (and even
* recursive), the save area must be stacked.  The stack pointer
* is saved in 'STKGOS.X'.  The old 'STKGOS.X' is saved on the stack.
* If we are in the main routine, 'STKGOS.X' is zero (this was done
* in the initialization section of the interpreter), but we still
* save it as a flag for no further 'RETURN's.
*
* 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
* returns the execution to the command after the most recent
* 'GOSUB'.  If 'STKGOS.X' is zero, it indicates that we never had
* a 'GOSUB' and is thus an error.
*
GOSUB   BSR        PUSHA           save the current 'FOR' parameters
        BSR        EXPR                get line number
        MOVE.L     A0,-(A7)        save text pointer
        MOVE.L     D0,D1
        BSR        FNDLN                find the target line
        BNE        AHOW                if not there, say 'How?'
        MOVE.L     CURRNT.X,-(A7)  found it, save old 'CURRNT.X'...
        MOVE.L     STKGOS.X,-(A7)        and 'STKGOS.X'
        CLR.L      LOPVAR.X                load new values
        MOVE.L     A7,STKGOS.X
        BRA        RUNTSL

RETURN  BSR        ENDCHK                there should be just a <CR>
        MOVE.L     STKGOS.X,D1        get old stack pointer
        BEQ        QWHAT                if zero, it doesn't exist
        MOVEA.L    D1,A7                else restore it
        MOVE.L     (A7)+,STKGOS.X        and the old 'STKGOS.X'
        MOVE.L     (A7)+,CURRNT.X        and the old 'CURRNT.X'
        MOVEA.L    (A7)+,A0        and the old text pointer
        BSR        POPA                and the old 'FOR' parameters
        BRA        FINISH                and we are back home

*
*******************************************************************
*
* *** FOR *** & NEXT ***
*
* 'FOR' has two forms:
* 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
* The second form means the same thing as the first form with a
* STEP of positive 1.  The interpreter will find the variable 'var'
* and set its value to the current value of 'exp1'.  It also
* evaluates 'exp2' and 'exp1' and saves all these together with
* the text pointer, etc. in the 'FOR' save area, which consisits of
* 'LOPVAR.X', 'LOPINC.X', 'LOPLMT.X', 'LOPLN.X', and 'LOPPT.X'.  If 
* there is already something in the save area (indicated by a non-zero
* 'LOPVAR.X'), then the old save area is saved on the stack before
* the new values are stored.  The interpreter will then dig in the
* stack and find out if this same variable was used in another
* currently active 'FOR' loop.  If that is the case, then the old
* 'FOR' loop is deactivated. (i.e. purged from the stack)
*
* 'NEXT var' serves as the logical (not necessarily physical) end
* of the 'FOR' loop.  The control variable 'var' is checked with
* the 'LOPVAR.X'.  If they are not the same, the interpreter digs in
* the stack to find the right one and purges all those that didn't
* match.  Either way, it then adds the 'STEP' to that variable and
* checks the result with against the limit value.  If it is within
* the limit, control loops back to the command following the
* 'FOR'.  If it's outside the limit, the save area is purged and
* execution continues.
*
FOR     BSR        PUSHA                save the old 'FOR' save area
        BSR        SETVAL                set the control variable
        MOVE.L     A6,LOPVAR.X        save its address
        LEA        TAB5,A1                use 'EXEC' to test for 'TO'
        LEA        TAB51,A2
        BRA        EXEC
FR1     BSR        EXPR                evaluate the limit
        MOVE.L     D0,LOPLMT.X        save that
        LEA        TAB6,A1                use 'EXEC' to look for the
        LEA        TAB61,A2        word 'STEP'
        BRA        EXEC
FR2     BSR        EXPR                found it, get the step value
        BRA        FR4
FR3     MOVEQ      =1,D0                not found, step defaults to 1
FR4     MOVE.L     D0,LOPINC.X        save that too
FR5     MOVE.L     CURRNT.X,LOPLN.X  save address of current line number
        MOVE.L     A0,LOPPT.X        and text pointer
        MOVEA.L    A7,A6          dig into the stack to find 'LOPVAR.X'
        BRA        FR7
FR6     ADDA.L     =20,A6                look at next stack frame
FR7     MOVE.L     (A6),D0                is it zero?
        BEQ        FR8                if so, we're done
        CMP.L      LOPVAR.X,D0        same as current LOPVAR.X?
        BNE        FR6                nope, look some more
        MOVEA.L    A7,A2                Else remove 5 long words from...
        MOVEA.L    A6,A1                inside the stack.
        LEA        20,A3
        ADDA.L     A1,A3
        BSR        MVDOWN
        MOVEA.L    A3,A7                set the A7 5 long words up
FR8     BRA        FINISH                and continue execution

NEXT    BSR        TSTV                get address of variable
        BCS        QWHAT                if no variable, say 'What?'
        MOVEA.L    D0,A1                save variable's address
NX0     MOVE.L     LOPVAR.X,D0        If 'LOPVAR.X' is zero, we never...
        BEQ        QWHAT                had a FOR loop, so say 'What?'
        CMPA.L     D0,A1                else we check them
        BEQ        NX3                OK, they agree
        BSR        POPA                nope, let's see the next frame
        BRA        NX0
NX3     MOVE.L     (A1),D0                get control variable's value
        ADD.L      LOPINC.X,D0        add in loop increment
        BVS        QHOW                say 'How?' for 32-bit overflow
        MOVE.L     D0,(A1)        save control variable's new value
        MOVE.L     LOPLMT.X,D1        get loop's limit value
        TST.L      LOPINC.X
        BPL        NX1            branch if loop increment is positive
        EXG        D0,D1
NX1     CMP.L      D0,D1                test against limit
        BLT        NX2                branch if outside limit
        MOVE.L     LOPLN.X,CURRNT.X  Within limit, go back to the...
        MOVEA.L    LOPPT.X,A0        saved 'CURRNT.X' and text pointer.
        BRA        FINISH
NX2     BSR        POPA                purge this loop
        BRA        FINISH

*
*******************************************************************
*
* *** REM *** IF *** INPUT *** LET (& DEFLT) ***
*
* 'REM' can be followed by anything and is ignored by the
* interpreter.
*
* 'IF' is followed by an expression, as a condition and one or
* more commands (including other 'IF's) separated by colons.
* Note that the word 'THEN' is not used.  The interpreter evaluates
* the expression.  If it is non-zero, execution continues.  If it
* is zero, the commands that follow are ignored and execution
* continues on the next line.
*
* 'INPUT' is like the 'PRINT' command, and is followed by a list
* of items.  If the item is a string in single or double quotes,
* or is an underline (back arrow), it has the same effect as in
* 'PRINT'.  If an item is a variable, this variable name is
* printed out followed by a colon, then the interpreter waits for
* an expression to be typed in.  The variable is then set to the
* value of this expression.  If the variable is preceeded by a
* string (again in single or double quotes), the string will be
* displayed followed by a colon.  The interpreter the waits for an
* expression to be entered and sets the variable equal to the
* expression's value.  If the input expression is invalid, the
* interpreter will print 'What?', 'How?', or 'Sorry' and reprint
* the prompt and redo the input.  The execution will not terminate
* unless you press control-C.  This is handled in 'INPERR'.
*
* 'LET' is followed by a list of items separated by commas.
* Each item consists of a variable, an equals sign, and an
* expression.  The interpreter evaluates the expression and sets
* the variable to that value.  The interpreter will also handle
* 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
*
REM     BRA        IF2                skip the rest of the line

IF      BSR        EXPR                evaluate the expression
IF1     TST.L      D0                is it zero?
        BNE        RUNSML                if not, continue
IF2     MOVEA.L    A0,A1
        CLR.L      D1
        BSR        FNDSKP            if so, skip the rest of the line
        BCC        RUNTSL                and run the next line
        BRA        WSTART            if no next line, do a warm start

INPERR  MOVEA.L    STKINP.X,A7        restore the old stack pointer
        MOVE.L     (A7)+,CURRNT.X        and old 'CURRNT.X'
        ADDQ.L     =4,A7
        MOVEA.L    (A7)+,A0        and old text pointer

INPUT   MOVE.L     A0,-(A7)        save in case of error
        BSR        QTSTG                is next item a string?
*zzz    BRA.S      IP2         nope 
        BRA.S      IP2         nope 
        BSR        TSTV        yes, but is it followed by a variable?
        BCS        IP4                if not, branch
        MOVEA.L    D0,A2                put away the variable's address
        BRA        IP3                if so, input to variable
IP2     MOVE.L     A0,-(A7)        save for 'PRTSTG'
        BSR        TSTV                must be a variable now
        BCS        QWHAT                'What?' it isn't?
        MOVEA.L    D0,A2                put away the variable's address
        MOVE.B     (A0),D2                get ready for 'PRTSTG'
        CLR.B      D0
        MOVE.B     D0,(A0)
        MOVEA.L    (A7)+,A1
        BSR        PRTSTG                print string as prompt
        MOVE.B     D2,(A0)                restore text
IP3     MOVE.L     A0,-(A7)        save in case of error
        MOVE.L     CURRNT.X,-(A7)        also save 'CURRNT.X'
        MOVE.L     =-1,CURRNT.X        flag that we are in INPUT
        MOVE.L     A7,STKINP.X        save the stack pointer too
        MOVE.L     A2,-(A7)        save the variable address
        MOVE.B     =COLON,D0         print a colon first
        BSR        GETLN                then get an input line
        LEA        BUFFER.X,A0        point to the buffer
        BSR        EXPR                evaluate the input
        MOVEA.L    (A7)+,A2        restore the variable address
        MOVE.L     D0,(A2)                save value in variable
        MOVE.L     (A7)+,CURRNT.X        restore old 'CURRNT.X'
        MOVEA.L    (A7)+,A0        and the old text pointer
IP4     ADDQ.L     =4,A7                clean up the stack
        BSR        TSTC                is the next thing a comma?
        DC.B       ',',IP5-$
        BRA        INPUT                yes, more items
IP5     BRA        FINISH

DEFLT   CMPI.B     =CR,(A0)        empty line is OK
        BEQ        LT1                else it is 'LET'

LET     BSR        SETVAL                do the assignment
        BSR        TSTC                check for more 'LET' items
        DC.B        ',',LT1-$
        BRA        LET
LT1     BRA        FINISH                until we are finished.

*
*******************************************************************
*
* *** LOAD *** & SAVE ***
*
* These two commands transfer a program to/from an auxiliary
* device such as a cassette, another computer, etc.  The program
* is converted to an easily-stored format: each line starts with
* a colon, the line no. as 4 hex digits, and the rest of the line.
* At the end, a line starting with an '@' sign is sent.  This
* format can be read back with a minimum of processing time by
* the 68000.
*
LOAD    BSR        PARSENAME        parse the filename
        MOVEA.L    TXTBGN.X,A0        set pointer to start of prog. area
        BSR        OPENFILE        go open the file for output
LOD1    BSR        GOAUXI                look for start of line
        BEQ        LOD1
        CMP.B      =ATXX,D0                end of program?
        BEQ        LODEND
        CMP.B      =COLON,D0         if not, is it start of line?
        BNE        LOD1                if not, wait for it
        BSR        GBYTE                get first byte of line no.
        MOVE.B     D1,(A0)+        store it
        BSR        GBYTE                get 2nd bye of line no.
        MOVE.B     D1,(A0)+        store that, too
LOD2    BSR        GOAUXI                get another text char.
        BEQ        LOD2
        MOVE.B     D0,(A0)+        store it
        CMP.B      =CR,D0                is it the end of the line?
        BNE        LOD2                if not, go back for more
        BRA        LOD1                if so, start a new line
LODEND  MOVE.L     A0,TXTUNF.X        set end-of program pointer
        BSR        CLOSEFILE        close the file 
        BRA        WSTART                back to direct mode

GBYTE   MOVEQ      =1,D2         get two hex characters from auxiliary
        CLR        D1                and store them as a byte in D1
GBYTE1  BSR        GOAUXI                get a char.
        BEQ        GBYTE1
        CMP.B      =AXX,D0
        BCS        GBYTE2
        SUBQ.B     =7,D0                if greater than 9, adjust
GBYTE2  AND.B      =$F,D0                strip ASCII
        LSL.B      =4,D1                put nybble into the result
        OR.B       D0,D1
        DBF        D2,GBYTE1        ;DBRA get another char.
        RTS

SAVE    BSR        PARSENAME        parse the filename out of the buffer
        MOVEA.L    TXTBGN.X,A0        set pointer to start of prog. area
        MOVEA.L    TXTUNF.X,A1        set pointer to end of prog. area
        BSR        CREATFILE
SAVE1   MOVE.B     =CR,D0           send out a CR & LF (CP/M likes this)
        BSR        GOAUXO
        MOVE.B     =LF,D0
        BSR        GOAUXO
        CMPA.L     A0,A1                are we finished?
        BLS        SAVEND
        MOVE.B     =COLON,D0       if not, start a line
        BSR        GOAUXO
        MOVE.B     (A0)+,D1        send first half of line no.
        BSR        PBYTE
        MOVE.B     (A0)+,D1        and send 2nd half
        BSR        PBYTE
SAVE2   MOVE.B     (A0)+,D0        get a text char.
        CMP.B      =CR,D0                is it the end of the line?
        BEQ        SAVE1          if so, send CR & LF and start new line
        BSR        GOAUXO                send it out
        BRA        SAVE2                go back for more text
SAVEND  MOVE.B     =ATXX,D0                send end-of-program indicator
        BSR        GOAUXO
        MOVE.B     =CR,D0                followed by a CR & LF
        BSR        GOAUXO
        MOVE.B     =LF,D0
        BSR        GOAUXO
        MOVE.B     =$1A,D0        and a control-Z to end the CP/M file
        BSR        GOAUXO
        BSR        CLOSEFILE
        BRA        WSTART                then go do a warm start

PBYTE   MOVEQ      =1,D2      send two hex characters from D1's low byte
PBYTE1  ROL.B      =4,D1                get the next nybble
        MOVE.B     D1,D0
        AND.B      =$F,D0                strip off garbage
        ADD.B      =N0,D0                make it into ASCII
        CMP.B      =N9,D0
        BLS        PBYTE2
        ADDQ.B     =7,D0                adjust if greater than 9
PBYTE2  BSR        GOAUXO                send it out
        DBF        D2,PBYTE1        ;DBRA then send the next nybble
        RTS

*
*******************************************************************
*
* *** POKE *** & CALL ***
*
* 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
* address specified by 'expr1'.
*
* 'CALL expr' jumps to the machine language subroutine whose
* starting address is specified by 'expr'.  The subroutine can use
* all registers but must leave the stack the way it found it.
* The subroutine returns to the interpreter by executing an RTS.
*
POKE    BSR        EXPR                get the memory address
        BSR        TSTC                it must be followed by a comma
        DC.B       ',',PKER-$
        MOVE.L     D0,-(A7)        save the address
        BSR        EXPR                get the byte to be POKE'd
        MOVEA.L    (A7)+,A1        get the address back
        
        OFF                          ;Zugriff im Supervisormode
        MOVE.B     D0,(A1)           ;store the byte in memory
        QDPC                         ;Dispatcherstart forcieren
        
        BRA        FINISH
PKER    BRA        QWHAT                if no comma, say 'What?'

CALL    BSR        EXPR                get the subroutine's address
        TST.L      D0                make sure we got a valid address
        BEQ        QHOW                if not, say 'How?'
        MOVE.L     A0,-(A7)        save the text pointer
        MOVEA.L    D0,A1
        JSR        (A1)                jump to the subroutine
        MOVEA.L    (A7)+,A0        restore the text pointer
        BRA        FINISH
*
*******************************************************************
*
* *** EXPR ***
*
* 'EXPR' evaluates arithmetical or logical expressions.
* <EXPR>::=<EXPR2>
*           <EXPR2><rel.op.><EXPR2>
* where <rel.op.> is one of the operators in TAB8 and the result
* of these operations is 1 if true and 0 if false.
* <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
* where () are optional and (... are optional repeats.
* <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
* <EXPR4>::=<variable>
*            <function>
*            (<EXPR>)
* <EXPR> is recursive so that the variable '@' can have an <EXPR>
* as an index, functions can have an <EXPR> as arguments, and
* <EXPR4> can be an <EXPR> in parenthesis.
*
EXPR    BSR        EXPR2
        MOVE.L     D0,-(A7)        save <EXPR2> value
        LEA        TAB8,A1                look up a relational operator
        LEA        TAB81,A2
        BRA        EXEC                go do it

XP11    BSR        XP18                is it '>='?
        BLT        XPRT0                no, return D0=0
        BRA        XPRT1                else return D0=1

XP12    BSR        XP18                is it '<>'?
        BEQ        XPRT0                no, return D0=0
        BRA        XPRT1                else return D0=1

XP13    BSR        XP18                is it '>'?
        BLE        XPRT0                no, return D0=0
        BRA        XPRT1                else return D0=1

XP14    BSR        XP18                is it '<='?
        BGT        XPRT0                no, return D0=0
        BRA        XPRT1                else return D0=1

XP15    BSR        XP18                is it '='?
        BNE        XPRT0                if not, return D0=0
        BRA        XPRT1                else return D0=1
XP15RT  RTS

XP16    BSR        XP18                is it '<'?
        BGE        XPRT0                if not, return D0=0
        BRA        XPRT1                else return D0=1
XP16RT  RTS

XPRT0   CLR.L      D0                return D0=0 (false)
        RTS

XPRT1   MOVEQ      =1,D0                return D0=1 (true)
        RTS

XP17    MOVE.L     (A7)+,D0        it's not a rel. operator
        RTS                        return D0=<EXPR2>

XP18    MOVE.L     (A7)+,D0        reverse the top two stack items
        MOVE.L     (A7)+,D1
        MOVE.L     D0,-(A7)
        MOVE.L     D1,-(A7)
        BSR        EXPR2                do second <EXPR2>
        MOVE.L     (A7)+,D1
        CMP.L      D0,D1                compare with the first result
        RTS                        return the result

EXPR2   BSR        TSTC                negative sign?
        DC.B       '-',XP21-$
        CLR.L      D0                yes, fake '0-'
        BRA        XP26
XP21    BSR        TSTC                positive sign? ignore it
        DC.B        '+',XP22-$
XP22    BSR        EXPR3                first <EXPR3>
XP23    BSR        TSTC                add?
        DC.B       '+',XP25-$
        MOVE.L     D0,-(A7)        yes, save the value
        BSR        EXPR3                get the second <EXPR3>
XP24    MOVE.L     (A7)+,D1
        ADD.L      D1,D0                add it to the first <EXPR3>
        BVS        QHOW                branch if there's an overflow
        BRA        XP23                else go back for more operations
XP25    BSR        TSTC                subtract?
        DC.B       '-',XP42-$
XP26    MOVE.L     D0,-(A7)        yes, save the result of 1st <EXPR3>
        BSR        EXPR3                get second <EXPR3>
        NEG.L      D0                change its sign
        JMP        XP24                and do an addition

EXPR3   BSR        EXPR4                get first <EXPR4>
XP31    BSR        TSTC                multiply?
        DC.B       '*',XP34-$
        MOVE.L     D0,-(A7)        yes, save that first result
        BSR        EXPR4                get second <EXPR4>
        MOVE.L     (A7)+,D1
        BSR        MULT32                multiply the two
        BRA        XP31                then look for more terms
XP34    BSR        TSTC                divide?
        DC.B       '/',XP42-$
        MOVE.L     D0,-(A7)        save result of 1st <EXPR4>
        BSR        EXPR4                get second <EXPR4>
        MOVE.L     (A7)+,D1
        EXG        D0,D1
        BSR        DIV32                do the division
        BRA        XP31                go back for any more terms

EXPR4   LEA        TAB4,A1                find possible function
        LEA        TAB41,A2
        BRA        EXEC
XP40    BSR        TSTV                nope, not a function
        BCS        XP41                nor a variable
        MOVEA.L    D0,A1
        CLR.L      D0
        MOVE.L     (A1),D0        if a variable, return its value in D0
EXP4RT  RTS
XP41    BSR        TSTNUM                or is it a number?
        MOVE.L     D1,D0
        TST        D2                (if not, = of digits will be zero)
        BNE        EXP4RT                if so, return it in D0
PARN    BSR        TSTC                else look for ( EXPR )
        DC.B       '(',XP43-$
        BSR        EXPR
        BSR        TSTC
        DC.B       ')',XP43-$
XP42    RTS
XP43    BRA        QWHAT                else say 'What?'

*
* =====        Test for a valid variable name.  Returns Carry=1 if not
*        found, else returns Carry=0 and the address of the
*        variable in D0.

TSTV    BSR        IGNBLK
        CLR.L      D0
        MOVE.B     (A0),D0                look at the program text
        SUB.B      =ATXX,D0
        BCS        TSTVRT                C=1: not a variable
        BNE        TV1                branch if not '@' array
        ADDA       =1,A0                If it is, it should be
        BSR        PARN                followed by (EXPR) as its index.
        ADD.L      D0,D0
        BCS        QHOW                say 'How?' if index is too big
        ADD.L      D0,D0
        BCS        QHOW
        MOVE.L     D0,-(A7)        save the index
        BSR        SIZE                get amount of free memory
        MOVE.L     (A7)+,D1        get back the index
        CMP.L      D1,D0                see if there's enough memory
        BLS        QSORRY                if not, say 'Sorry'
        MOVE.L     VARBGN.X,D0        put address of array element...
        SUB.L      D1,D0                into D0
        RTS
TV1     CMP.B      =27,D0                if not @, is it A through Z?
*zzz    EORI       =1,CCR               Unterstes Byte SR = CCR
        EORI.B     =1,SR                Zugriff im UserMode erlaubt
        BCS        TSTVRT                if not, set Carry and return
        ADDQ       =1,A0                else bump the text pointer
        ADD        D0,D0                compute the variable's address
        ADD        D0,D0
        MOVE.L     VARBGN.X,D1
        ADD        D1,D0                and return it in D0 with Carry=0
TSTVRT  RTS

*
* =====        Multiplies the 32 bit values in D0 and D1, returning
*        the 32 bit result in D0.
*
MULT32  MOVE.L     D1,D4
        EOR.L      D0,D4                see if the signs are the same
        TST.L      D0                take absolute value of D0
        BPL        MLT1
        NEG.L      D0
MLT1    TST.L      D1                take absolute value of D1
        BPL        MLT2
        NEG.L      D1
MLT2    CMP.L      =$FFFF,D1        is second argument <= 16 bits?
        BLS        MLT3                OK, let it through
        EXG        D0,D1                else swap the two arguments
        CMP.L      =$FFFF,D1        and check 2nd argument again
        BHI        QHOW                one of them MUST be 16 bits
MLT3    MOVE       D0,D2          prepare for 32 bit X 16 bit multiply
        MULU       D1,D2                multiply low word
        SWAP       D0
        MULU       D1,D0                multiply high word
        SWAP       D0
        ADD.L      D2,D0                D0 now holds the product
        BCS        QHOW                if overflow, say 'How?'
        TST.L      D4                were the signs the same?
        BPL        MLTRET
        NEG.L      D0                if not, make the result negative
MLTRET  RTS

*
* ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
*        Returns the 32 bit quotient in D0, remainder in D1.
*
DIV32   TST.L      D1                check for divide-by-zero
        BEQ        QHOW                if so, say 'How?'
        MOVE.L     D1,D2
        MOVE.L     D1,D4
        EOR.L      D0,D4                see if the signs are the same
        TST.L      D0                take absolute value of D0
        BPL        DIV1
        NEG.L      D0
DIV1    TST.L      D1                take absolute value of D1
        BPL        DIV2
        NEG.L      D1
DIV2    MOVEQ      =31,D3                iteration count for 32 bits
        MOVE.L     D0,D1
        CLR.L      D0
DIV3    ADD.L      D1,D1           (This algorithm was translated from
        ADDX.L     D0,D0                the divide routine in Ron Cain's
        BEQ        DIV4                Small-C run time library.)
        CMP.L      D2,D0
        BMI        DIV4
        ADDQ.L     =1,D1
        SUB.L      D2,D0
DIV4    DBF        D3,DIV3           ;DBRA
        EXG        D0,D1          put rem. & quot. in proper registers
        TST.L      D4                were the signs the same?
        BPL        DIVRT
        NEG.L      D0                if not, results are negative
        NEG.L      D1
DIVRT   RTS

*
* =====        The PEEK function returns the byte stored at the address
*        contained in the following expression.
*
PEEK    BSR        PARN                get the memory address
        MOVEA.L    D0,A1
        CLR.L      D0                upper 3 bytes will be zero
        
        OFF                          ;Zugriff im Supervisormode
        MOVE.B     (A1),D0           ;get the addressed byte
        QDPC                         ;Dispatcherstart forcieren

        RTS                        and return it

*
* =====        The RND function returns a random number from 1 to
*        the value of the following expression in D0.
*
RND     BSR        PARN                get the upper limit
        TST.L      D0                it must be positive and non-zero
        BEQ        QHOW
        BMI        QHOW
        MOVE.L     D0,D1
        MOVEA.L    RANPNT.X,A1        get memory as a random number
        CMPA.L     =LSTROM,A1
        BCS        RA1
        LEA        START,A1        wrap around if end of program
RA1     MOVE.L     (A1)+,D0        get the slightly random number
        BCLR        =31,D0                make sure it's positive
        MOVE.L     A1,RANPNT.X        (even I can do better than this!)
        BSR        DIV32                RND(n)=MOD(number,n)+1
        MOVE.L     D1,D0                MOD is the remainder of the div.
        ADDQ.L     =1,D0
        RTS

*
* =====        The ABS function returns an absolute value in D0.
*
ABS     BSR        PARN                get the following expr.'s value
        TST.L      D0
        BPL        ABSRT
        NEG.L      D0                if negative, complement it
        BMI        QHOW                if still negative, it was too big
ABSRT   RTS

*
* ===== The SIZE function returns the size of free memory in D0.
*
SIZE    MOVE.L     VARBGN.X,D0        get the number of free bytes...
        SUB.L      TXTUNF.X,D0        between 'TXTUNF.X' and 'VARBGN.X'
        RTS                        return the number in D0

*
*******************************************************************
*
* *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
*
* 'SETVAL' expects a variable, followed by an equal sign and then
* an expression.  It evaluates the expression and sets the variable
* to that value.
*
* 'FIN' checks the end of a command.  If it ended with ':',
* execution continues.  If it ended with a CR, it finds the
* the next line and continues from there.
*
* 'ENDCHK' checks if a command is ended with a CR. This is
* required in certain commands, such as GOTO, RETURN, STOP, etc.
*
* 'ERROR' prints the string pointed to by A0. It then prints the
* line pointed to by CURRNT.X with a '?' inserted at where the
* old text pointer (should be on top of the stack) points to.
* Execution of Tiny BASIC is stopped and a warm start is done.
* If CURRNT.X is zero (indicating a direct command), the direct
* command is not printed. If CURRNT.X is -1 (indicating
* 'INPUT' command in progress), the input line is not printed
* and execution is not terminated but continues at 'INPERR'.
*
* Related to 'ERROR' are the following:
* 'QWHAT' saves text pointer on stack and gets 'What?' message.
* 'AWHAT' just gets the 'What?' message and jumps to 'ERROR'.
* 'QSORRY' and 'ASORRY' do the same kind of thing.
* 'QHOW' and 'AHOW' also do this for 'How?'.
*
SETVAL  BSR        TSTV                variable name?
        BCS        QWHAT                if not, say 'What?'
        MOVE.L     D0,-(A7)        save the variable's address
        BSR        TSTC                get past the '=' sign
        DC.B       '=',SV1-$
        BSR        EXPR                evaluate the expression
        MOVEA.L    (A7)+,A6
        MOVE.L     D0,(A6)          and save its value in the variable
        RTS
SV1     BRA        QWHAT                if no '=' sign

FIN     BSR        TSTC                *** FIN ***
        DC.B       ':',FI1-$
        ADDQ.L     =4,A7                if ':', discard return address
        BRA        RUNSML                continue on the same line
FI1     BSR        TSTC                not ':', is it a CR?
        DC.B       CR,FI2-$
        ADDQ.L     =4,A7                yes, purge return address
        BRA        RUNNXL                execute the next line
FI2     RTS                        else return to the caller

ENDCHK  BSR        IGNBLK
        CMPI.B     =CR,(A0)        does it end with a CR?
        BNE        QWHAT                if not, say 'WHAT?'
        RTS

QWHAT   MOVE.L     A0,-(A7)
AWHAT   LEA        WHTMSG,A6
ERROR   BSR        PRMESG                display the error message
        MOVEA.L    (A7)+,A0        restore the text pointer
        MOVE.L     CURRNT.X,D0        get the current line number
        BEQ        WSTART                if zero, do a warm start
        CMP.L      =-1,D0                is the line no. pointer = -1?
        BEQ        INPERR                if so, redo input
        MOVE.B     (A0),-(A7)        save the char. pointed to
        CLR.B      (A0)                put a zero where the error is
        MOVEA.L    CURRNT.X,A1        point to start of current line
        BSR        PRTLN         display the line in error up to the 0
        MOVE.B     (A7)+,(A0)        restore the character
        MOVE.B     =QMARK,D0                display a '?'
        BSR        GOOUT
        CLR        D0
        SUBQ.L     =1,A1                point back to the error char.
        BSR        PRTSTG                display the rest of the line
        BRA        WSTART                and do a warm start
QSORRY  MOVE.L     A0,-(A7)
ASORRY  LEA        SRYMSG,A6
        BRA        ERROR
QHOW    MOVE.L     A0,-(A7)        Error: 'How?'
AHOW    LEA        HOWMSG,A6
        BRA        ERROR
FERROR  BSR        CLOSEFILE        close the open file
        MOVE.L     A0,-(A7)
        LEA        FERRMSG,A6        Error: 'File Error'
        BRA        ERROR
*
*******************************************************************
*
* *** GETLN *** FNDLN (& friends) ***
*
* 'GETLN' reads in input line into 'BUFFER'. It first prompts with
* the character in D0 (given by the caller), then it fills the
* buffer and echos. It ignores LF's but still echos
* them back. Control-H is used to delete the last character
* entered (if there is one), and control-X is used to delete the
* whole line and start over again. CR signals the end of a line,
* and causes 'GETLN' to return.
*
* 'FNDLN' finds a line with a given line no. (in D1) in the
* text save area.  A1 is used as the text pointer. If the line
* is found, A1 will point to the beginning of that line
* (i.e. the high byte of the line no.), and flags are NC & Z.
* If that line is not there and a line with a higher line no.
* is found, A1 points there and flags are NC & NZ. If we reached
* the end of the text save area and cannot find the line, flags
* are C & NZ.
* 'FNDLN' will initialize A1 to the beginning of the text save
* area to start the search. Some other entries of this routine
* will not initialize A1 and do the search.
* 'FNDLNP' will start with A1 and search for the line no.
* 'FNDNXT' will bump A1 by 2, find a CR and then start search.
* 'FNDSKP' uses A1 to find a CR, and then starts the search.
*kkk
GETLN   BSR        GOOUT                display the prompt
        MOVE.B     =SPACE,D0                and a space
        BSR        GOOUT
        LEA        BUFFER.X,A0        A0 is the buffer pointer
GL1     BSR        CHKIO                check keyboard
        BEQ        GL1                wait for a char. to come in
        CMP.B      =CTRLH,D0        delete last character?
        BEQ        GL3                if so
        CMP.B      =CTRLX,D0        delete the whole line?
        BEQ        GL4                if so
        CMP.B      =CR,D0                accept a CR
        BEQ        GL2
        CMP.B      =SPACE,D0       if other control char., discard it
        BCS        GL1
GL2     MOVE.B     D0,(A0)+        save the char.
        BSR        GOOUT                echo the char back out
        CMP.B      =CR,D0                if it's a CR, end the line
        BEQ        GL7
        
*zzz    CMPA.L     =(BUFFER+BUFLEN-1),A0        any more room?
        MOVE.L     A0,D6  
        LEA        BUFFER+BUFLEN-1(A5),A0
        EXG        D6,A0
        CMPA.L     D6,A0                        any more room?

        BCS        GL1        yes: get some more, else delete last char.
GL3     MOVE.B     =CTRLH,D0        delete a char. if possible
        BSR        GOOUT
        MOVE.B     =SPACE,D0
        BSR        GOOUT

*zzz    CMPA.L     =BUFFER,A0        any char.'s left? 
        MOVE.L     A0,D6  
        LEA        BUFFER.X,A0
        EXG        D6,A0
        CMPA.L     D6,A0             any char.'s left? 
             
        BLS        GL1                if not
        MOVE.B     =CTRLH,D0    if so, finish the BS-space-BS sequence
        BSR        GOOUT
        SUBQ.L     =1,A0                decrement the text pointer
        BRA        GL1                back for more        
GL4     MOVE.L     A0,D1                delete the whole line

*zzz    SUB.L      =BUFFER,D1   figure out how many backspaces we need
        MOVE.L     A0,D6  
        LEA        BUFFER.X,A0
        EXG        D6,A0
        SUB.L      A0,D1        figure out how many backspaces we need

        BEQ        GL6                if none needed, branch
        SUBQ       =1,D1                adjust for DBRA/DBF
GL5     MOVE.B     =CTRLH,D0        and display BS-space-BS sequences
        BSR        GOOUT
        MOVE.B     =SPACE,D0
        BSR        GOOUT
        MOVE.B     =CTRLH,D0
        BSR        GOOUT
        DBF        D1,GL5            ;DBRA
GL6     LEA        BUFFER.X,A0        reinitialize the text pointer
        BRA        GL1                and go back for more
GL7     MOVE.B     =LF,D0                echo a LF for the CR
        BSR        GOOUT
        RTS

FNDLN   CMP.L      =$FFFF,D1        line no. must be < 65535
        BCC        QHOW
        MOVEA.L    TXTBGN.X,A1        init. the text save pointer

FNDLNP  MOVEA.L    TXTUNF.X,A2        check if we passed the end
        SUBQ.L     =1,A2
        CMPA.L     A1,A2
        BCS        FNDRET                if so, return with Z=0 & C=1
        MOVE.B     (A1)+,D2        if not, get a line no.
        LSL        =8,D2
        MOVE.B     (A1),D2
        SUBQ.L     =1,A1
        CMP        D1,D2                is this the line we want?
        BCS        FNDNXT                no, not there yet
FNDRET  RTS                        return the cond. codes

FNDNXT  ADDQ.L     =2,A1                find the next line

FNDSKP  CMPI.B      =CR,(A1)+        try to find a CR
        BNE        FNDSKP                keep looking
        BRA        FNDLNP                check if end of text

*
*******************************************************************
*
* *** MVUP *** MVDOWN *** POPA *** PUSHA ***
*
* 'MVUP' moves a block up from where A1 points to where A2 points
* until A1=A3
*
* 'MVDOWN' moves a block down from where A1 points to where A3
* points until A1=A2
*
* 'POPA' restores the 'FOR' loop variable save area from the stack
*
* 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
*
MVUP    CMPA.L     A1,A3                see the above description
        BEQ        MVRET
        MOVE.B     (A1)+,(A2)+
        BRA        MVUP
MVRET   RTS

MVDOWN  CMPA.L     A1,A2                see the above description
        BEQ        MVRET
        MOVE.B     -(A1),-(A3)
        BRA        MVDOWN

POPA    MOVEA.L    (A7)+,A6        A6 = return address
        MOVE.L     (A7)+,LOPVAR.X     
*                              restore LOPVAR.X, but zero means no more
        BEQ        PP1
        MOVE.L     (A7)+,LOPINC.X        if not zero, restore the rest
        MOVE.L     (A7)+,LOPLMT.X
        MOVE.L     (A7)+,LOPLN.X
        MOVE.L     (A7)+,LOPPT.X
PP1     JMP        (A6)                return

PUSHA   MOVE.L     STKLMT.X,D1        Are we running out of stack room?
        SUB.L      A7,D1
        BCC        QSORRY                if so, say we're sorry
        MOVEA.L    (A7)+,A6        else get the return address
        MOVE.L     LOPVAR.X,D1        save loop variables
        BEQ        PU1                if LOPVAR.X is zero, that's all
        MOVE.L     LOPPT.X,-(A7)        else save all the others
        MOVE.L     LOPLN.X,-(A7)
        MOVE.L     LOPLMT.X,-(A7)
        MOVE.L     LOPINC.X,-(A7)
PU1     MOVE.L     D1,-(A7)
        JMP        (A6)                return

*
*******************************************************************
*
* *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
*
* 'PRTSTG' prints a string pointed to by A1. It stops printing
* and returns to the caller when either a CR is printed or when
* the next byte is the same as what was passed in D0 by the
* caller.
*
* 'QTSTG' looks for an underline (back-arrow on some systems),
* single-quote, or double-quote.  If none of these are found, returns
* to the caller.  If underline, outputs a CR without a LF.  If single
* or double quote, prints the quoted string and demands a matching
* end quote.  After the printing, the next 2 bytes of the caller are
* skipped over (usually a short branch instruction).
*
* 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
* needed to pad the number of spaces to the number in D4.
* However, if the number of digits is larger than the no. in
* D4, all digits are printed anyway. Negative sign is also
* printed and counted in, positive sign is not.
*
* 'PRTLN' prints the saved text line pointed to by A1
* with line no. and all.
*
PRTSTG  MOVE.B     D0,D1                save the stop character
PS1     MOVE.B     (A1)+,D0        get a text character
        CMP.B      D0,D1                same as stop character?
        BEQ        PRTRET                if so, return
        BSR        GOOUT                display the char.
        CMP.B      =CR,D0                is it a C.R.?
        BNE        PS1                no, go back for more
        MOVE.B     =LF,D0                yes, add a L.F.
        BSR        GOOUT
PRTRET  RTS                        then return

QTSTG   BSR        TSTC                *** QTSTG ***
        DC.B       '"',QT3-$
        MOVE.B     =DQUOTE,D0                it is a DQUOTE
QT1     MOVEA.L    A0,A1
        BSR        PRTSTG                print until another
        MOVEA.L    A1,A0
        MOVEA.L    (A7)+,A1        pop return address
        CMP.B      =LF,D0                was last one a CR? 
        BEQ        RUNNXL                if so, run next line
QT2     ADDQ.L     =2,A1                skip 2 bytes on return
        JMP        (A1)                return
QT3     BSR        TSTC                is it a single quote?
        DC.B       SQUOTE,QT4-$
        MOVE.B     =SQUOTE,D0        if so, do same as above
        BRA        QT1
QT4     BSR        TSTC                is it an underline?
        DC.B       '_',QT5-$
        MOVE.B     =CR,D0                if so, output a CR without LF
        BSR        GOOUT
        MOVEA.L    (A7)+,A1        pop return address
        BRA        QT2
QT5     RTS                        none of the above

PRTNUM  MOVE.L     D1,D3                save the number for later
        MOVE       D4,-(A7)        save the width value
        MOVE.B     =$FF,-(A7)        flag for end of digit string
        TST.L      D1                is it negative?
        BPL        PN1                if not
        NEG.L      D1                else make it positive
        SUBQ       =1,D4                one less for width count
PN1     DIVU       =10,D1                get the next digit
        BVS        PNOV                overflow flag set?
        MOVE.L     D1,D0                if not, save remainder
        AND.L      =$FFFF,D1        strip the remainder
        BRA        TOASCII                skip the overflow stuff
PNOV    MOVE       D1,D0                prepare for long word division
        CLR.W      D1                zero out low word
        SWAP       D1                high word into low
        DIVU       =10,D1                divide high word
        MOVE       D1,D2                save quotient
        MOVE       D0,D1                low word into low
        DIVU       =10,D1                divide low word
        MOVE.L     D1,D0                D0 = remainder
        SWAP       D1                R/Q becomes Q/R
        MOVE       D2,D1                D1 is low/high
        SWAP       D1                D1 is finally high/low
TOASCII SWAP       D0                get remainder
        MOVE.B     D0,-(A7)        stack it as a digit
        SWAP       D0
        SUBQ       =1,D4                decrement width count
        TST.L      D1                if quotient is zero, we're done
        BNE        PN1
        SUBQ       =1,D4       adjust padding count for DBRA/DBF
        BMI        PN4                skip padding if not needed
PN3     MOVE.B     =SPACE,D0   display the required leading spaces
        BSR        GOOUT
        DBF        D4,PN3       ;DBRA
PN4     TST.L      D3                is number negative?
        BPL        PN5
        MOVE.B     =MINUS,D0                if so, display the sign
        BSR        GOOUT
PN5     MOVE.B     (A7)+,D0        now unstack the digits and display
        BMI        PNRET                until the flag code is reached
        ADD.B      =N0,D0                make into ASCII
        BSR        GOOUT
        BRA        PN5
PNRET   MOVE       (A7)+,D4        restore width value
        RTS

PRTLN   CLR.L      D1
        MOVE.B     (A1)+,D1        get the binary line number
        LSL        =8,D1
        MOVE.B     (A1)+,D1
        MOVEQ      =5,D4                display a 5 digit line no.
        BSR        PRTNUM
        MOVE.B     =SPACE,D0                followed by a blank
        BSR        GOOUT
        CLR        D0                stop char. is a zero
        BRA        PRTSTG                display the rest of the line

*
* ===== Test text byte following the call to this subroutine. If it
*        equals the byte pointed to by A0, return to the code following
*        the call. If they are not equal, branch to the point
*        indicated by the offset byte following the text byte.
*
TSTC    BSR        IGNBLK                ignore leading blanks
        MOVEA.L    (A7)+,A1        get the return address
        MOVE.B     (A1)+,D1        get the byte to compare
        CMP.B      (A0),D1                is it = to what A0 points to?
        BEQ        TC1                if so
        CLR.L      D1                If not, add the second
        MOVE.B     (A1),D1                byte following the call to
        ADDA.L     D1,A1                the return address.
        SUBQ.L     =1,A1                for DRI's assembler
        JMP        (A1)                jump to the routine
TC1     ADDQ.L     =1,A0                if equal, bump text pointer
        ADDQ.L     =1,A1                Skip the 2 bytes following
        JMP        (A1)                the call and continue.

*
* ===== See if the text pointed to by A0 is a number. If so,
*        return the number in D1 and the number of digits in D2,
*        else return zero in D1 and D2.
*
TSTNUM  CLR.L      D1                initialize return parameters
        CLR        D2
        BSR        IGNBLK                skip over blanks
TN1     CMPI.B     =N0,(A0)        is it less than zero?
        BCS        TSNMRET                if so, that's all
        CMPI.B     =N9,(A0)        is it greater than nine?
        BHI        TSNMRET                if so, return
        CMP.L      =214748364,D1    see if there's room for new digit
        BCC        QHOW                if not, we've overflowd
        MOVE.L     D1,D0                quickly multiply result by 10
        ADD.L      D1,D1
        ADD.L      D1,D1
        ADD.L      D0,D1
        ADD.L      D1,D1
        MOVE.B     (A0)+,D0        add in the new digit
        AND.L      =$F,D0
        ADD.L      D0,D1
        ADDQ        =1,D2                increment the no. of digits
        BRA        TN1
TSNMRET RTS

*
* ===== Skip over blanks in the text pointed to by A0.
*
IGNBLK  CMPI.B     =SPACE,(A0)        see if it's a space
        BNE        IGBRET                if so, swallow it
IGB1    ADDQ.L     =1,A0                increment the text pointer
        BRA        IGNBLK
IGBRET  RTS

*
* =====        Convert the line of text in the input buffer to upper
*        case (except for stuff between quotes).
*
TOUPBUF LEA        BUFFER.X,A0        set up text pointer
        CLR.B      D1                clear quote flag
TOUPB1  MOVE.B     (A0)+,D0        get the next text char.
        CMP.B      =CR,D0                is it end of line?
        BEQ        TOUPBRT                if so, return
        CMP.B      =DQUOTE,D0                a double quote?
        BEQ        DOQUO
        CMP.B      =SQUOTE,D0        or a single quote?
        BEQ        DOQUO
        TST.B      D1                inside quotes?
        BNE        TOUPB1                if so, do the next one
        BSR        TOUPPER                convert to upper case
        MOVE.B     D0,-(A0)        store it
        ADDQ.L     =1,A0
        BRA        TOUPB1                and go back for more
TOUPBRT RTS

DOQUO   TST.B      D1                are we inside quotes?
        BNE        DOQUO1
        MOVE.B     D0,D1            if not, toggle inside-quotes flag
        BRA        TOUPB1
DOQUO1  CMP.B      D0,D1            make sure we're ending proper quote
        BNE        TOUPB1                if not, ignore it
        CLR.B      D1                else clear quote flag
        BRA        TOUPB1

*
* ===== Convert the character in D0 to upper case
*
TOUPPER CMP.B      =AYY,D0                is it < 'a'?
        BCS        TOUPRET
        CMP.B      =ZYY,D0                or > 'z'?
        BHI        TOUPRET
        SUB.B      =32,D0                if not, make it upper case
TOUPRET RTS

*
* 'CHKIO' checks the input. If there's no input, it will return
* to the caller with the Z flag set. If there is input, the Z
* flag is cleared and the input byte is in D0. However, if a
* control-C is read, 'CHKIO' will warm-start BASIC and will not
* return to the caller.
*
CHKIO   BSR        GOIN                get input if possible
        BEQ        CHKRET                if Zero, no input
        CMP.B      =CTRLC,D0        is it control-C?
        BNE        CHKRET                if not
        BRA        WSTART                if so, do a warm start
CHKRET  RTS

*
* ===== Display a CR-LF sequence
*
CRLF    LEA        CLMSG,A6

*
* =====        Display a zero-ended string pointed to by register A6
PRMESG  MOVE.B     (A6)+,D0        get the char.
        BEQ        PRMRET                if it's zero, we're done
        BSR        GOOUT                else display it
        BRA        PRMESG
PRMRET  RTS

******************************************************
* The following routines are the only ones that need *
* to be changed for a different I/O environment.     *
******************************************************

*
* ===== Output character to the console (Port 1) from register D0
*        (Preserves all registers.)
*
OUTCH   MOVEM.L    D0-D7/A0-A6,-(A7)        save the registers
        
        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODMOU+MODMSC+$0,MODE(A1)
        MOVE.B     =11,LDNIO(A1)          ; ATARI-ST: /D1
        MOVE       =0,DRV(A1)
        MOVEA.L    BUADR(A1),A2
        MOVE.B     D0,(A2)+
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        RELCE
         
        .ELSE
        MOVE.W     =2,-(A7)        is device 2 ready for a character?
        MOVE.W     =8,-(A7)        check routine
        TRAP       =13
        ADDQ       =4,A7
        TST.L      D0                is it zero
        BEQ        OUTCH                if not, wait for it
        MOVE.L     (A7),D0                get it back
        MOVE.W     D0,-(A7)        out it goes.
        MOVE.W     =2,-(A7)
        MOVE.W     =3,-(A7)        bconout call
        TRAP       =13
        ADDQ       =6,A7
        .FIN
        
        MOVEM.L    (A7)+,D0-D7/A0-A6        get back orginal character
        RTS

        .IF        VERSION
*
* ===== Output character to the console (Port 1) from register D0
*        (Preserves all registers.)
*
OUTCH2  MOVEM.L    D0-D7/A0-A6,-(A7)        save the registers
        
        .IF        OS
        MOVE       =128,D1
        FETCE
        MOVE.B     =MODMOU+$0,MODE(A1)
        MOVE.B     =0,LDNIO(A1)          ; ATARI-ST: /A1
        MOVE       =0,DRV(A1)
        MOVEA.L    BUADR(A1),A2
        MOVE.B     D0,(A2)+
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        RELCE
        .FIN
        
        MOVEM.L    (A7)+,D0-D7/A0-A6        get back orginal character
        RTS
        .FIN

*
* ===== Input a character from the console into register D0 (or
*        return Zero status if there's no character available).
*
INCH    MOVEM.L    D1-D7/A0-A6,-(A7)

        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODMSC+MODMNE+$0,MODE(A1)
        MOVE.B     =0,LDNIO(A1)        ; ATARI-ST: /C1
        MOVE       =6,DRV(A1)
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        MOVEA.L    BUADR(A1),A2
        MOVE.B     (A2)+,D0
        RELCE
        
        .ELSE
        MOVE.W     =2,-(A7)        device =2
        MOVE.W     =1,-(A7)        bconstat call
        TRAP       =13
        ADDQ       =4,A7
        TST.L      D0
        BEQ        INCRET                if not, return Zero status
        MOVE.W     =2,-(A7)        else get the character
        MOVE.W     =2,-(A7)
        TRAP       =13
        ADDQ       =4,A7
        .FIN
        
        AND.L      =$7F,D0         zero out the high bit
INCRET  MOVEM.L    (A7)+,D1-D7/A0-A6        restore the registers
        RTS

*
* ===== Output character to the host (Port 2) from register D0
*        (Preserves all registers.)
*
AUXOUT:
        MOVEM.L    D0-D7/A0-A6,-(A7)        save registers

        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODBIN+MODMOU+$0,MODE(A1)
        MOVE.B     =FWRITE+EXCLU+NERR,M2ODE(A1)

        LEA        FILENAME.X,A2
        LEA        FNAME(A1),A3

AUXOUT2 MOVE.B     (A2)+,D1
        MOVE.B     D1,(A3)+
        CMP.B      =$FF,D1
        BEQ        AUXOUT3
        BRA        AUXOUT2

AUXOUT3 MOVE.B     =3,LDNIO(A1)          ; ATARI-ST: /F0
        MOVE       =0,DRV(A1)
        MOVEA.L    BUADR(A1),A2
        MOVE.B     D0,(A2)+
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        MOVE       RECLEN(A1),D1
        RELCE

        CMP        =0,D1   
        BEQ        FERROR                oops an error occurred

        .ELSE
        MOVE.B     D0,OUTBYTE.X      put the output byte in a buffer

*zzz    MOVE.L     =OUTBYTE.X,-(A7)        address of the buffer
        LEA        OUTBYTE.X,A0            address of the buffer
        MOVE.L     A0,-(A7)          

        MOVE.L     =1,-(A7)                write one character
        MOVE.W     FHANDLE.X,-(A7)        file handle to write to
        MOVE.W     =$40,-(A7)                file write opcode
        TRAP       =1                        go write the byte
        ADDA.L     =12,A7                        clean up stack pointer
        CMP.L      =0,D0                        any errors
        BMI        FERROR                        no errors
        .FIN
        
        MOVEM.L    (A7)+,D0-D7/A0-A6        return registers
                
        RTS

*
* ===== Input a character from the host into register D0 (or
*        return Zero status if there's no character available).
*
AUXIN:
        MOVEM.L    D1-D7/A0-A6,-(A7)        save the registers

        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODBIN+$0,MODE(A1)
        MOVE.B     =FREAD+EXCLU+NERR,M2ODE(A1)

        LEA        FILENAME.X,A2
        LEA        FNAME(A1),A3

AUXIN2  MOVE.B     (A2)+,D1
        MOVE.B     D1,(A3)+
        CMP.B      =$FF,D1
        BEQ        AUXIN3
        BRA        AUXIN2

AUXIN3  MOVE.B     =3,LDNIO(A1)        ; ATARI-ST: /F0
        MOVE       =0,DRV(A1)
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        MOVEA.L    BUADR(A1),A2
        MOVE.B     (A2)+,D0
        MOVE       RECLEN(A1),D1
        RELCE

        CMP        =0,D1   
        BLE        FERROR                oops an error occurred

        .ELSE
*zzz    MOVE.L     =INBYTE.X,-(A7)         input character buffer
        LEA        INBYTE.X,A0             input character buffer
        MOVE.L     A0,-(A7)          

        MOVE.L     =1,-(A7)                number of characters
        MOVE.W     FHANDLE.X,-(A7)                file handle
        MOVE.W     =$3F,-(A7)                file write opcode
        TRAP       =1                        go do the operation
        ADDA.L     =12,A7                        clean up
        CMP.L      =0,D0                        see if error
        BMI        FERROR
        MOVE.B     INBYTE.X,D0                get the character
        .FIN
 
        MOVEM.L    (A7)+,D1-D7/A0-A6        return registers
        RTS

*
* ===== Parse the filename out of the buffer if there is one
*
PARSENAME:
*zzz    MOVEM.L    D0/A0-A1,-(A7)
        MOVEM.L    D0/A0-A2,-(A7)
        LEA        FILENAME.X,A1
PN_L1   MOVE.B     (A0)+,D0        get the byte
        CMP.B      =DQUOTE,D0    compare with DQUOTE for start of string
        BEQ        L1QUOTE                load found 1 quote

*zzz    CMPA.L     =BUFFER+BUFLEN,A0  see if we are at end of buffer zzz
        LEA        BUFFER+BUFLEN(A5),A2  
        CMPA.L     A2,A0              see if we are at end of buffer zzz

        BLT        PN_L1
        BRA        QWHAT              say what is the matter
L1QUOTE MOVE.B     (A0)+,D0           get the byte pointer
        CMP.B      =DQUOTE,D0         end of the string
        BEQ        L2QUOTE            found the second quote

*zzz    CMPA.L     =BUFFER+BUFLEN,A0
        LEA        BUFFER+BUFLEN(A5),A2  
        CMPA.L     A2,A0                 

        BGE        QWHAT
        MOVE.B     D0,(A1)+        put in filename buffer
        BRA        L1QUOTE

        .IF        OS
L2QUOTE MOVE.B     =$FF,(A1)+  put end of filename
        .ELSE 
L2QUOTE MOVE.B     =0,(A1)+    put end of filename
        .FIN
          
*zzz    MOVEM.L    (A7)+,D0/A0-A1        restore registers
        MOVEM.L    (A7)+,D0/A0-A2        restore registers
        RTS
        
        
*
* ===== Open a file for output to the disk drive
*
OPENFILE:
        MOVEM.L    D0-D7/A0-A6,-(A7)        save the registers

        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODBIN+$0,MODE(A1)
        MOVE.B     =FOPEN+EXCLU+NERR,M2ODE(A1)

        LEA        FILENAME.X,A2
        LEA        FNAME(A1),A3

OPEN2   MOVE.B     (A2)+,D1
        MOVE.B     D1,(A3)+
        CMP.B      =$FF,D1
        BEQ        OPEN3
        BRA        OPEN2

OPEN3:  MOVE.B     =3,LDNIO(A1)        ; ATARI-ST: /F0
        MOVE       =0,DRV(A1)
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        MOVEA.L    BUADR(A1),A2
        MOVE.B     (A2)+,D0
        MOVE       RECLEN(A1),D1
        RELCE

        CMP        =0,D1   
        BLE        FERROR                oops an error occurred
        
        .ELSE 
        MOVE.W     =2,-(A7)        read/write mode for file
        MOVE.L     FILENAME.X,-(A7)        the address of the filename
        MOVE.W     =$3D,-(A7)        open file opcode
        TRAP       =1
        ADDQ       =8,A7
        MOVE.W     D0,FHANDLE.X        save the handle
        CMP.W      =0,D0
        BLT        FERROR                oops an error occurred
        .FIN
        
        MOVEM.L    (A7)+,D0-D7/A0-A6        restore the registers
        RTS

*
* ===== Create a file for output to the disk drive
*
CREATFILE:
        MOVEM.L    D0-D7/A0-A6,-(A7)        save the registers

        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODBIN+MODMOU+$0,MODE(A1)
        MOVE.B     =FCREATE+EXCLU+NERR,M2ODE(A1)

        LEA        FILENAME.X,A2
        LEA        FNAME(A1),A3

CREAT2  MOVE.B     (A2)+,D1
        MOVE.B     D1,(A3)+
        CMP.B      =$FF,D1
        BEQ        CREAT3
        BRA        CREAT2

CREAT3: MOVE.B     =3,LDNIO(A1)        ; ATARI-ST: /F0
        MOVE       =0,DRV(A1)
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        MOVEA.L    BUADR(A1),A2
        MOVE.B     (A2)+,D0
        MOVE.B     RECLEN(A1),D1
        RELCE

        CMP        =0,D1                
        BEQ        FERROR                oops an error occurred
        
        .ELSE 
        CLR.W      -(A7)                read/write mode for file
        MOVE.L     FILENAME.X,-(A7)        the address of the filename
        MOVE.W     =$3C,-(A7)        open file opcode
        TRAP       =1
        ADDQ       =8,A7
        MOVE.W     D0,FHANDLE.X        save the handle
        CMP.W      =0,D0
        BLT        FERROR                oops an error occurred
        .FIN
        
        MOVEM.L    (A7)+,D0-D7/A0-A6        restore the registers
        RTS

*
* ===== Close a file that was open
*
CLOSEFILE:
        MOVEM.L    D0-D7/A0-A6,-(A7)        save the registers

        .IF        OS
        MOVEQ      =2,D1
        FETCE
        MOVE.B     =MODBIN+$0,MODE(A1)
        MOVE.B     =FCLOSE+EXCLU+NERR,M2ODE(A1)

        LEA        FILENAME.X,A2
        LEA        FNAME(A1),A3

CLOSE2  MOVE.B     (A2)+,D1
        MOVE.B     D1,(A3)+
        CMP.B      =$FF,D1
        BEQ        CLOSE3
        BRA        CLOSE2

CLOSE3: MOVE.B     =3,LDNIO(A1)        ; ATARI-ST: /F0
        MOVE       =0,DRV(A1)
        MOVE       =1,RECLEN(A1)
        XIO
        IOWA
        MOVEA.L    BUADR(A1),A2
        MOVE.B     (A2)+,D0
        RELCE

        .ELSE
        MOVE.W     FHANDLE.X,-(A7)        save the handle
        MOVE.W     =$3E,-(A7)
        TRAP       =1
        TST.L      (A7)+                clean up stack pointer
        .FIN
 
        MOVEM.L    (A7)+,D0-D7/A0-A6        restore the registers
        RTS

*
* =====        Return to the resident monitor, operating system, etc.
*
BYEBYE  NOP

* 
* RTOS-UH: Eingabe/Ausgabe Unterbrechungsmoeglichkeit fuer
*          Kommandozeilen-Befehle (CTRL-A) wieder einschalten
*
        .IF        VERSION
        MOVE.B     =CR,D0 
        BSR        GOOUT2
        .FIN
* 
* Register fuer RTOS-Hyperprozessor Wiedereintritt zurueckladen
*

        MOVEA.L    OLDSTACK.X,A7   
*zzz    MOVE.W     =0,-(A7)        return to Tutor
*
        RETN


**********************************************************************
* DATEN
**********************************************************************
        

INITMSG  DC.B      CR,LF,'Gordo`s MC68000 Tiny BASIC, v1.0'
         DC.B      CR,LF,CR,LF
         DC.B      'V3.0 for RTOS-UH adapted by'
         DC.B      ' Kenneth L. Hurley'
         DC.B      ' and'
         DC.B      ' Rolf Hemmerling'
         DC.B      CR,LF,LF,0
OKMSG    DC.B      CR,LF,'OK',CR,LF,0
HOWMSG   DC.B      'How?',CR,LF,0
WHTMSG   DC.B      'What?',CR,LF,0
SRYMSG   DC.B      'Sorry.'
FERRMSG  DC.B      'File Error!',CR,LF,0
CLMSG    DC.B      CR,LF,0
         DC.B      0        ;<- for aligning on a word boundary
LSTROM   DS        0        ;end of possible ROM area

*
* Internal variables follow:
*

* RANPNT   DC.L    START   random number pointer
* ENDMEM   DC.L    0       end of memory pointer
* FHANDLE  DC.W    0       file handle for file operations
* OUTBYTE  DC.B    0       output the byte to the file
* INBYTE   DC.B    0       input the byte from the file
* FILENAME DS      65      buffer for the filename
* CURRNT   DC.L    0       Current line pointer
* STKGOS   DC.L    0       Saves stack pointer in 'GOSUB'
* STKINP   DC.L    0       Saves stack pointer during 'INPUT'
* LOPVAR   DC.L    0       'FOR' loop save area
* LOPINC   DC.L    0       increment
* LOPLMT   DC.L    0       limit
* LOPLN    DC.L    0       line number
* LOPPT    DC.L    0       text pointer
* TXTUNF   DC.L    0       points to unfilled text area
* VARBGN   DC.L    0       points to variable area
* STKLMT   DC.L    0       holds lower limit for stack growth
* BUFFER   DS      BUFLEN  Keyboard input buffer
* TXT      DS      0       Beginning of program area

*
           END     TB1
*
